{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstra.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","row","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","isWeight","extraClassName","id","className","Component","dijkstra","grid","startNode","endNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","weight","previousNode","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","PathfindingVisualizer","weightChangeHandler","event","setState","target","value","pointChangeHandler","notCorrect","document","getElementById","parseInt","isNaN","toggleWeight","temp","changeWeight","mouseIsPressed","topMessage","distanceToBeTraveled","getInitialGrid","newGrid","getNewGridWithWeightToggled","getNewGridWithWallToggled","finishNode","nodesInShortestPathOrder","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","i","setTimeout","animateShortestPath","timeTaken","button_task","onClick","visualizeDijkstra","href","window","location","reload","changeWeightText","textBox","htmlFor","type","name","min","max","onChange","defaultValue","row_max_length","col_max_length","style","width","margin","classNamey","borderSpacing","map","rowIndex","nodeIndex","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","newNode","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.e6532f32.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      isWeight,\r\n    } = this.props;\r\n\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : isWeight\r\n      ? \"node-weight\"\r\n      : \"\";\r\n\r\n    return (\r\n      <td\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      ></td> // It is used to create the grid.\r\n    );\r\n  }\r\n}","// Implementing dijkstra algorithm.\r\n// Dijkstra is a weighted algorithm,weights are non-negative in this algorithm.\r\n\r\n// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dijkstra(grid, startNode, endNode) {\r\n  const visitedNodesInOrder = []; // To animate visited nodes in order to animate the process of searching.\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue; // Here isWall is the property of the node.\r\n\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    // Checking for the success condition.\r\n    if (closestNode === endNode) return visitedNodesInOrder;\r\n\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\n// Sorts the unvisitedNodes every time it is called.\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\n// Sets the neighbour nodes distance and also the previous node property.\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    \r\n    neighbor.distance = node.distance + neighbor.weight + 1; \r\n    // Now the neighbor distance is not infinity and because of it it will show among the top in unvisited nodes.\r\n    neighbor.previousNode = node; // With this property we can backtrack and find the shortest path between the start and end node.\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node; //col and row are properties of the node.\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited); // filtering the visited node\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node.jsx\";\r\n\r\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\r\n\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\n// Defining initial state of start and finish.\r\n\r\nlet row_max_length = 20;\r\nlet col_max_length = 40;\r\n\r\nlet START_NODE_ROW = 9;\r\nlet START_NODE_COL = 8;\r\nlet FINISH_NODE_ROW = 9;\r\nlet FINISH_NODE_COL = 31;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      topMessage: \"Dijkstra Algorithm\",\r\n      weight: 1,\r\n      changeWeight: false,\r\n      distanceToBeTraveled: 0,\r\n    };\r\n  }\r\n\r\n  // Creating grid\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  // On pressing the mouse down\r\n  handleMouseDown(row, col) {\r\n    if (this.state.topMessage !== \"Dijkstra Algorithm\") return;\r\n\r\n    let newGrid = [];\r\n\r\n    if (this.state.changeWeight) {\r\n      newGrid = getNewGridWithWeightToggled(\r\n        this.state.grid,\r\n        row,\r\n        col,\r\n        this.state.weight\r\n      );\r\n    } else {\r\n      newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    }\r\n\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n  }\r\n\r\n  // On entering the new node element.\r\n  handleMouseEnter(row, col) {\r\n    if (this.state.topMessage !== \"Dijkstra Algorithm\") return;\r\n    if (!this.state.mouseIsPressed) return;\r\n\r\n    let newGrid = [];\r\n\r\n    if (this.state.changeWeight) {\r\n      newGrid = getNewGridWithWeightToggled(\r\n        this.state.grid,\r\n        row,\r\n        col,\r\n        this.state.weight\r\n      );\r\n    } else {\r\n      newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    }\r\n\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n  }\r\n\r\n  // When we release the mouse\r\n  handleMouseUp() {\r\n    if (this.state.topMessage !== \"Dijkstra Algorithm\") return;\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  visualizeDijkstra() {\r\n    this.setState({ topMessage: \"Creator : Suhaan\" });\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\r\n      // When we reach the last element in visitedNodesInOrder.\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.setState({ topMessage: \"Shortest Path\" });\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n\r\n      if (i === visitedNodesInOrder.length - 1) continue;\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        if (node.isWeight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visitedWeight\";\r\n        } else {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visited\";\r\n        }\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    let timeTaken = 0;\r\n    for (let i = 1; i < nodesInShortestPathOrder.length - 1; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        if (nodesInShortestPathOrder[i].isWeight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-path-weight\";\r\n        } else {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-path\";\r\n        }\r\n      }, 50 * i);\r\n    }\r\n\r\n    timeTaken =\r\n      nodesInShortestPathOrder[nodesInShortestPathOrder.length - 1].distance;\r\n    this.setState({ distanceToBeTraveled: timeTaken });\r\n  }\r\n\r\n  // onClick={() => this.resetGrid()}\r\n  // resetGrid() {\r\n\r\n  //   const newGrid = getInitialGrid();\r\n\r\n  //   START_NODE_ROW = 0;\r\n  //   START_NODE_COL = 0;\r\n  //   FINISH_NODE_ROW = row_max_length - 1;\r\n  //   FINISH_NODE_COL = col_max_length - 1;\r\n\r\n  //   document.getElementById(\"start_row\").value = START_NODE_ROW;\r\n  //   document.getElementById(\"start_col\").value = START_NODE_COL;\r\n  //   document.getElementById(\"end_row\").value = FINISH_NODE_ROW;\r\n  //   document.getElementById(\"end_col\").value = FINISH_NODE_COL;\r\n\r\n  //   for (let row = 0; row < row_max_length; row++) {\r\n  //     for (let col = 0; col < col_max_length; col++) {\r\n  //       if (row === START_NODE_ROW && col === START_NODE_COL) {\r\n  //         document.getElementById(`node-${row}-${col}`).className =\r\n  //           \"node node-start\";\r\n  //       } else if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\r\n  //         document.getElementById(`node-${row}-${col}`).className =\r\n  //           \"node node-finish\";\r\n  //       } else {\r\n  //         document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n  //       }\r\n  //     }\r\n  //   }\r\n  //   this.setState({ topMessage: \"Dijkstra Algorithm\" });\r\n\r\n  //   this.setState({ grid: newGrid });\r\n  // }\r\n\r\n  weightChangeHandler = (event) => {\r\n    this.setState({ weight: event.target.value });\r\n  };\r\n\r\n  pointChangeHandler = () => {\r\n    if (this.notCorrect()) return; //To check if the provided value is suitable or not.\r\n\r\n    document.getElementById(\r\n      `node-${START_NODE_ROW}-${START_NODE_COL}`\r\n    ).className = \"node\";\r\n    document.getElementById(\r\n      `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\r\n    ).className = \"node\";\r\n\r\n    START_NODE_ROW = parseInt(document.getElementById(\"start_row\").value);\r\n    START_NODE_COL = parseInt(document.getElementById(\"start_col\").value);\r\n    FINISH_NODE_ROW = parseInt(document.getElementById(\"end_row\").value);\r\n    FINISH_NODE_COL = parseInt(document.getElementById(\"end_col\").value);\r\n\r\n    document.getElementById(\r\n      `node-${START_NODE_ROW}-${START_NODE_COL}`\r\n    ).className = \"node node-start\";\r\n    document.getElementById(\r\n      `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\r\n    ).className = \"node node-finish\";\r\n  };\r\n\r\n  notCorrect = () => {\r\n    if (\r\n      isNaN(parseInt(document.getElementById(\"start_row\").value)) ||\r\n      isNaN(parseInt(document.getElementById(\"start_col\").value)) ||\r\n      isNaN(parseInt(document.getElementById(\"end_row\").value)) ||\r\n      isNaN(parseInt(document.getElementById(\"end_col\").value))\r\n    )\r\n      return true;\r\n\r\n    if (\r\n      parseInt(document.getElementById(\"start_row\").value) > row_max_length ||\r\n      parseInt(document.getElementById(\"start_col\").value) > col_max_length\r\n    )\r\n      return true;\r\n    if (\r\n      parseInt(document.getElementById(\"start_row\").value) < 0 ||\r\n      parseInt(document.getElementById(\"start_col\").value) < 0\r\n    )\r\n      return true;\r\n\r\n    if (\r\n      parseInt(document.getElementById(\"end_row\").value) > row_max_length ||\r\n      parseInt(document.getElementById(\"end_col\").value) > col_max_length\r\n    )\r\n      return true;\r\n    if (\r\n      parseInt(document.getElementById(\"end_row\").value) < 0 ||\r\n      parseInt(document.getElementById(\"end_col\").value) < 0\r\n    )\r\n      return true;\r\n\r\n    return false;\r\n  };\r\n\r\n  toggleWeight = () => {\r\n    const temp = this.state.changeWeight;\r\n    this.setState({ changeWeight: !temp });\r\n  };\r\n\r\n  render() {\r\n    const {\r\n      grid,\r\n      mouseIsPressed,\r\n      topMessage,\r\n      distanceToBeTraveled,\r\n    } = this.state;\r\n    let button_task = (\r\n      <p className=\"btn\" onClick={() => this.visualizeDijkstra()}>\r\n        Start Dijkstra Algorithm\r\n      </p>\r\n    );\r\n\r\n    if (topMessage === \"Shortest Path\") {\r\n      button_task = (\r\n        <h2\r\n          className=\"btn\"\r\n          href=\"#\"\r\n          onClick={() => window.location.reload(false)}\r\n        >\r\n          Reset <br />\r\n          Time : {distanceToBeTraveled}\r\n          <small> [1 Block = 1 Time = 1 Weight]</small>\r\n        </h2>\r\n      );\r\n    } else if (topMessage === \"Creator : Suhaan\") {\r\n      button_task = <h3 className=\"running\">Running...</h3>;\r\n    }\r\n\r\n    let changeWeightText = \"False\";\r\n\r\n    if (this.state.changeWeight) changeWeightText = \"True\";\r\n\r\n    let textBox = (\r\n      <div className=\"textBox\">\r\n        <div className=\"weightContainer\">\r\n          <label htmlFor=\"quantity\">Toggle or Set Weight </label>\r\n\r\n          <input\r\n            type=\"number\"\r\n            id=\"quantity\"\r\n            name=\"quantity\"\r\n            min=\"1\"\r\n            max=\"5\"\r\n            onChange={this.weightChangeHandler}\r\n            defaultValue=\"1\"\r\n          />\r\n\r\n          <button onClick={this.toggleWeight}>{changeWeightText}</button>\r\n        </div>\r\n\r\n        <div className=\"startPointContainer\">\r\n          <label htmlFor=\"point\">Start Point :</label>\r\n          <input\r\n            type=\"number\"\r\n            name=\"point\"\r\n            id=\"start_row\"\r\n            min=\"0\"\r\n            max={row_max_length - 1}\r\n            onChange={this.pointChangeHandler}\r\n            defaultValue=\"9\"\r\n          ></input>\r\n          <input\r\n            type=\"number\"\r\n            name=\"point\"\r\n            id=\"start_col\"\r\n            min=\"0\"\r\n            max={col_max_length - 1}\r\n            onChange={this.pointChangeHandler}\r\n            defaultValue=\"8\"\r\n          ></input>\r\n        </div>\r\n\r\n        <div className=\"endPointContainer\">\r\n          <label htmlFor=\"point\">End Point :</label>\r\n          <input\r\n            type=\"number\"\r\n            name=\"point\"\r\n            id=\"end_row\"\r\n            min=\"0\"\r\n            max={row_max_length - 1}\r\n            onChange={this.pointChangeHandler}\r\n            defaultValue=\"9\"\r\n          ></input>\r\n          <input\r\n            type=\"number\"\r\n            name=\"point\"\r\n            id=\"end_col\"\r\n            min=\"0\"\r\n            max={col_max_length - 1}\r\n            onChange={this.pointChangeHandler}\r\n            defaultValue=\"31\"\r\n          ></input>\r\n        </div>\r\n\r\n        <div className=\"buttonContainer\">{button_task}</div>\r\n      </div>\r\n    );\r\n\r\n    if (topMessage === \"Creator : Suhaan\") {\r\n      textBox = null;\r\n    } else if (topMessage === \"Shortest Path\") {\r\n      textBox = (\r\n        <div\r\n          className=\"buttonContainer\"\r\n          style={{ width: \"30%\", margin: \"0 auto\" }}\r\n        >\r\n          {button_task}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return (\r\n      <div className=\"pathfindingVisualizer\">\r\n        <div className=\"container\">\r\n          <div className=\"heading\">\r\n            <h2>Search Visualizer</h2>\r\n            <h2>{topMessage}</h2>\r\n          </div>\r\n\r\n          {/* Show the header */}\r\n          {textBox}\r\n\r\n          <p>\r\n            Dijkstra's Algorithm is weighted and guarantees the shortest path!{\" \"}\r\n            <span classNamey=\"ref\"></span>\r\n          </p>\r\n        </div>\r\n\r\n        <div className=\"visualGridContainer\">\r\n          <div className=\"gridBox\">\r\n            <table className=\"grid\" style={{ borderSpacing: \"0\" }}>\r\n              <tbody>\r\n                {grid.map((row, rowIndex) => {\r\n                  return (\r\n                    <tr key={rowIndex}>\r\n                      {row.map((node, nodeIndex) => {\r\n                        const { isStart, isFinish, isWall, isWeight } = node; //Extracting from the node\r\n                        return (\r\n                          <Node\r\n                            row={rowIndex}\r\n                            col={nodeIndex}\r\n                            key={nodeIndex}\r\n                            isStart={isStart}\r\n                            isFinish={isFinish}\r\n                            isWall={isWall}\r\n                            isWeight={isWeight}\r\n                            mouseIsPressed={mouseIsPressed}\r\n                            onMouseDown={(row, col) =>\r\n                              this.handleMouseDown(row, col)\r\n                            }\r\n                            onMouseEnter={(row, col) =>\r\n                              this.handleMouseEnter(row, col)\r\n                            }\r\n                            onMouseUp={() => this.handleMouseUp()}\r\n                          ></Node>\r\n                        );\r\n                      })}\r\n                    </tr>\r\n                  );\r\n                })}\r\n              </tbody>\r\n            </table>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < row_max_length; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < col_max_length; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    isWeight: false,\r\n    previousNode: null,\r\n    weight: 0,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = [...grid];\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node, // copying other properties of the node\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithWeightToggled = (grid, row, col, weight) => {\r\n  const newGrid = [...grid];\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node, // copying other properties of the node\r\n    isWeight: !node.isWeight,\r\n    weight: parseInt(weight),\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","import './App.css';\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer.jsx'\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}